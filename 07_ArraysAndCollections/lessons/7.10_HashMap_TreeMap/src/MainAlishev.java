import java.util.HashMap;
import java.util.Map;

public class MainAlishev {
    public static void main(String[] args) {
        //Map - отображение (перев.). Как в математике отображение - это когда есть два множества, и мы элементы одного
        // множества сопоставляем элементам другого множества, т.е.
        // есть таблица какая-то: слева- номера классов школы, а справа сопоставляются ученики этих классов
        // 1 -> [.. .. ..]
        // 2 -> [.. .. .. ..]
        // в этой таблице множество классов (1, 2) - ключей (K), и множество значений (V) -учеников.
        // Структура данных Hashmap и вообще Map, позволяет организовать такую структуру данных
        // Все классы реализирующие интерфейс Map хранят пары: ключ-значение (K-V)

        Map<Integer, String> map = new HashMap<>(); // Integer -ключ (К), String - значение (V)

        // положим данные в map (допустим хотим хранить целое число и перевод его на русский язык)
        map.put(1, "Один");
        map.put(2, "Два");
        map.put(3, "Три");

        System.out.println(map); //т.к. объекты класса Map реализуют метод toString, то будет такой вывод:
        // консоль: {1=Один, 2=Два, 3=Три}

        // посмотрим как ведет себя map при вставке новых пар K-V ,если К уже существует в map
        map.put(3, "Другое значение для ключа три");
        System.out.println(map);
        // консоль: {1=Один, 2=Два, 3=Другое значение для ключа три}
        // старое значение (V) переписывается, т.е. в map не может быть дубликатов ключей

        System.out.println(map.get(1)); // этим методом получим значение (V) по ключу (K)
        // консоль: Один
        System.out.println(map.get(10)); // если укажем не существующий (К), вернется null (ничто)


        // Научимся проходится по элементам map (use foreach)

        for (Map.Entry<Integer, String> entry : map.entrySet()) {
            System.out.println(entry.getKey() + " : " + entry.getValue());
        }
        // Что здесь происходит?: каждая пара К-V это в java - {Entry}, т.е. Entry (целое число-Integer) на (строку-String)
        // т.е. в нашей map эти пары К-V не расматриваются отдельно как К и отдельно как V,
        // это расматривается как своя структура данных, просто включение значения пары К-V,
        // Map.Entry<Integer, String> - здесь получаем доступ к этой структуре данных К-V, мы ее параметризуем целым числом и строкой
        // и даем ей имя "entry" - Map.Entry<Integer, String> entry
        // далее вызываем метод .entrySet() на нашей map -> map.entrySet() -> этот метод возвращает набор всех пар К-V в этой map,
        // т.е. возвращает все объекты класса Entry, которые находятся в map
        // в блоке {} с этими объектами класса Entry мы уже можем взаимодействовать, можем вызвать у объекта класса Entry метод .getkey()
        // для того чтоб получить (К) у этого entry, и можем вызвать метод .getValue(), чтоб получить (V) этого entry
        // Т.к. здесь мы запрашиваем все entry, которые есть в map,т.е. все пары (К-V), мы проходимся по ним и вызываем у каждой пары
        // методы .getkey() .getValue()
        // консоль:
        /*1 : Один
          2 : Два
          3 : Другое значение для ключа три  */
        // У класса HashMap<> есть важная особенность: элементы не имеют какого либо порядка, не гарантирует порядок, здесь при выводе
        // на консоль повезло, вывело по порядку, а так все выводится в случайном порядке
        // используем HashMap когда не важен порядок пар К-V
        // Если важен порядок и нужно отсортировать, то нужно использовать другие классы, которые реализуют интерфейс Map


    }
}
