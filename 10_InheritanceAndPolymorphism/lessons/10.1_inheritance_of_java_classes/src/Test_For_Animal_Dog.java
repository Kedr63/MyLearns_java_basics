public class Test_For_Animal_Dog {
    public static void main(String[] args) {
        // Полиморфизм в ИТ - способность метода обрабатывать данные разных типов

        Animal animal = new Animal();
        Dog dog = new Dog();

        animal.eat();
        dog.eat();

        // Два объекта вызывают один и тот же метод
        // Консоль:
        /*
        Animal is eating...
        Animal is eating...
        */

        Animal animal1 = new Dog(); // Здесь переменная типа Animal, а справа - объект класса Dog
        // в этом и проявляется одна из сторон полиморфизма
        // т.е., мы к объекту класса Dog можем обращаться через переменную родит. типа, но это
        // имеет некоторые ограничения, посмотрим на примере:
        Dog dog1 = new Dog();
        dog1.eat();
        dog1.bark(); // здесь рассматриваем собаку как собаку и поэтому имеем доступ к методам
        // класса Dog

        Animal animal2 = new Dog(); // здесь собаку рассматриваем как животное, поэтому нет доступа к
        animal2.eat();              // методу класса Dog (к специфичным собачьим методам)
        /* animal2.bark();  нет доступа к методу */


        /*  Позднее связывание   */

        // Переопределим метод eat() в классе Dog
        Animal animal3 = new Dog();
        animal3.eat(); // Что теперь здесь выведется в консоль?
        //Консоль:
        /*Dog is eating...*/
        // Вывелось то что определено в потомке, т.е. несмотря на то, что мы эту собаку (new Dog()) воспринимаем
        // как животное, какое-то общее, вегда вызывается тот метод, который определен в потомке, если такой
        // имеется - это и называется поздним связыванием
        // Этот тип -"Animal" лишь определяет ограничения тех методов, которые мы можем вызвать, но сама реализация
        // методов, если она есть в потомке, то она и будет вызвана, если же ее (реализации метода) нет в потомке,
        // то будет вызвана та реализация которая есть у родителя


        /*  Посмотрим еще одну вещь, которая и делает полиморфизм такой выгодной и ролезной штукой  */
        // а именно - возможности передавать в метод разные типы, если у них есть один и тот же родитель
        // создадим метод test() и класс Cat
        Animal animal4 = new Animal();
        Dog dog2 = new Dog();
        Cat cat = new Cat();

        test(animal4);
        test(dog2); // благодаря полиморфизму, можем вызвать этот метод на объекте класса Dog, т.к. Dog наслед-ся от Animal
        test(cat);  // т.к. Cat наследуется от Animal
       /* Консоль:
        Animal is eating...
        Dog is eating...
        Animal is eating...*/

        // В чем практическая польза полиморфизма?
        // 1. Можем сделать код меньше
        // 2. Многоразовым
        // В нашем примере метод test() выполнился корректно на трех различных объектах, т.е.
        // мы вызвали метод test() на трех различных типах и при этом получили корректный результат.
        // Если бы полиморфизма не было, то для каждого типа (Animal, Dog, Cat) пришлось бы делать свой метод,
        // который бы обслуживал каждый из этих объектов
        // здесь же -  test(Animal animal), выставив правильную наследственную связь, мы обошлись одним методом,
        // который обслуживает общего родителя и потомки спокойно передаются в этот метод
    }

    public static void test(Animal animal) {
        animal.eat();
    }


}
