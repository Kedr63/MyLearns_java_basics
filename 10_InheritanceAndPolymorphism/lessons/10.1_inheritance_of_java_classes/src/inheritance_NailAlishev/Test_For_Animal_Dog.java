package inheritance_NailAlishev;

import inheritance_NailAlishev.Animal;
import inheritance_NailAlishev.Cat;
import inheritance_NailAlishev.Dog;

public class Test_For_Animal_Dog {
    public static void main(String[] args) {
        // Полиморфизм в ИТ - способность метода обрабатывать данные разных типов

        Animal animal = new Animal();
        Dog dog = new Dog();

        animal.eat();
        dog.eat();  // еще в классе Dog не переопределили метод eat()

        // Два объекта вызывают один и тот же метод
        // Консоль:
        /*
        Animal is eating...
        Animal is eating...
        */

        System.out.println();

        Animal animal1 = new Dog(); // Здесь переменная типа Animal, а справа - объект класса Dog
        // в этом и проявляется одна из сторон полиморфизма
        // т.е., мы к объекту класса Dog можем обращаться через переменную родит. типа, но это
        // имеет некоторые ограничения, посмотрим на примере:
        Dog dog1 = new Dog();
        dog1.eat();  // метод eat() переопределили в классе Dog
        dog1.bark(); // здесь рассматриваем собаку как собаку и поэтому имеем доступ к методам
        // класса Dog

        Animal animal2 = new Dog(); // здесь собаку рассматриваем как животное, поэтому нет доступа к
        animal2.eat();              // методу класса Dog (к специфичным собачьим методам)
        /* animal2.bark();  - нет доступа к методу */

        /*От Заура*/
        Animal animal7 = new Dog();
        // Переменная Animal может ссылаться на объект sub-класса. Что это означает?
        // Это означает, что референс (ссылочная) переменная animal7 типа Animal может ссылаться на объект
        // типа Dog, т.е. Dog - это Animal, справа налево читаем: собака - это животное.
        // Переменная супер-класса может ссылаться на любой объект sub-класса, но не наоборот.
        // Если переменная типа данных супер-класса ссылается на объект sub-класса, то с помощью этой переменной
        // можно вызывать только унаследованные от супер-класса элементы. (т.е. поля и методы Dog вызвать нельзя).


        /*  Позднее связывание   */

        // Переопределим метод eat() в классе Dog
        Animal animal3 = new Dog();
        animal3.eat(); // Что теперь здесь выведется в консоль?
        //Консоль:
        /* Dog is eating...*/
        // Вывелось то что определено в потомке, т.е. несмотря на то, что мы эту собаку (new Dog()) воспринимаем
        // как животное, какое-то общее, всегда вызывается тот метод, который определен в потомке, если такой
        // имеется - это и называется поздним связыванием
        // Этот тип -"Animal" лишь определяет ограничения тех методов, которые мы можем вызвать, но сама реализация
        // методов, если она есть в потомке, то она и будет вызвана, если же ее (реализации метода) нет в потомке,
        // то будет вызвана та реализация которая есть у родителя

        System.out.println();

        /*  Посмотрим еще одну вещь, которая и делает полиморфизм такой выгодной и ролезной штукой  */
        // а именно - возможности передавать в метод разные типы, если у них есть один и тот же родитель
        // создадим ⬇  метод test() и класс Cat
        Animal animal4 = new Animal();
        Dog dog2 = new Dog();
        Cat cat = new Cat();

        test(animal4);
        test(dog2); // благодаря полиморфизму, можем вызвать этот метод на объекте класса Dog,
        // т.к. Dog наслед-ся от Animal
        test(cat);  // т.к. Cat наследуется от Animal
       /* Консоль:
        Animal is eating...
        Dog is eating...
        Animal is eating...*/ // так как в классе Cat метод eat() не переопределен

        // В чем практическая польза полиморфизма?
        // 1. Можем сделать код меньше
        // 2. Многоразовым
        // В нашем примере метод test() выполнился корректно на трех различных объектах, т.е.
        // мы вызвали метод test() на трех различных типах и при этом получили корректный результат.
        // Если бы полиморфизма не было, то для каждого типа (Animal, Dog, Cat) пришлось бы делать свой метод,
        // который бы обслуживал каждый из этих объектов
        // здесь же -  test(Animal animal), выставив правильную наследственную связь, мы обошлись одним методом,
        // который обслуживает общего родителя и потомки спокойно передаются в этот метод
    }

    public static void test(Animal animal) {
        animal.eat();
    }


}
