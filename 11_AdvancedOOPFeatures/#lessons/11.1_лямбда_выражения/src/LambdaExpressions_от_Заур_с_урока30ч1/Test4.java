package LambdaExpressions_от_Заур_с_урока30ч1;

public class Test4 {
    static void def(Test5 t) {
        System.out.println(t.abc("privet"));
    }

    public static void main(String[] args) {
        def(x -> x.length());  // Что я сделал? У меня есть интерфейс Test5 с единственным методом /abc/
    }                         // который принимает в параметре String s. У меня есть метод /def/ в
    // параметре объект типа Test5 и я вывожу на экран результат вызова метода
    // /abc/  с параметром "privet", а что делает этот метод /abc/ с параметром "privet"-
    // я могу написать в методе main при вызове самого метода /def/. Вот я вызываю метод /def/ ->
    // и он в параметре исп-ет объект типа Test5. Вместо того чтобы создавать класс, который имплементирует
    // интерфейс, оверайдить /abc/, я прям внутри здесь - (x -> x.length()), оверайдю этот метод, и
    // пишу /х/ - это параметр, вместо /String s/ -пишу /х/ (Java понимает что String это /х/) и говорю - return
    // какой должен быть? -> /int/ и я возвращаю длину этого String-a (x.length()).
    // Внутри параметра метода /def/ я указал как должен работать метод /abc/, и поэтому когда я вызываю метод
    // /def/ он в параметре показывает как должен работать метод /abc/, поэтому на экран выводится: /t/ вызывает
    // метод /abc/ - этот метод /abc/ должен работать так: /x -> x.length()/, т.е. он получает параметр /х/, а
    // /х/ это "privet", он должен возвращать /x.length()/ -т.е. длину /х/
}

interface Test5 {
    int abc(String s);
}

   // Если наш метод не принимает параметров:
    // def(  () -> 5);

// Интерфейс Preticate<T> видео 01:08:31