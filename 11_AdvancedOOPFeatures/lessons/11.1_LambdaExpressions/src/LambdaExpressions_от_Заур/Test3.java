package LambdaExpressions_от_Заур;

import java.util.ArrayList;

public class Test3 {
}

class Student2 {
    String name;
    char sex;
    int age;
    int course;
    double avgGrade;

    Student2(String name, char sex, int age, int course, double avgGrade) {
        this.name = name;
        this.sex = sex;
        this.age = age;
        this.course = course;
        this.avgGrade = avgGrade;
    }
}

class StudentInfo2 {
    void printStudent(Student2 st) {
        System.out.println("Imya studenta: " + st.name + ", pol: " + st.sex + ", vozrast: "
                + st.age + ", kurs: " + st.course + ", srednyaa ocenka: " + st.avgGrade);
    }

    /*1*/
    // В третьем варианте будет менять метод /testStudents/, в теле метода ничего менять не будем
    // это означает что метод /testStudents/ что делает?
    // Он для каждого студента из листа /aL/ проверяет -> этот студент подходит под условия
    // фильтрации объекта /sc/ типа /StudentChecks1/ используя метод /test/? ->
    // если подходит под эту фильтрацию, тогда будет выводиться на экран этот студент.
    //     ⬇
    void testStudents(ArrayList<Student2> aL, StudentChecks1 sc) {
        for (Student2 s : aL) {
            if (sc.test(s)) {
                printStudent(s);
            }
        }
    }

    // И теперь поработаем
    public static void main(String[] args) {
        ArrayList<Student2> list2 = new ArrayList<>();
        Student2 st1 = new Student2("Ivan", 'm', 22, 3, 8.3);
        Student2 st2 = new Student2("Nikolay", 'm', 28, 2, 6.4);
        Student2 st3 = new Student2("Elena", 'f', 19, 1, 8.9);
        Student2 st4 = new Student2("Petr", 'm', 35, 4, 7);
        Student2 st5 = new Student2("Maria", 'f', 23, 3, 9.1);
        list2.add(st1);
        list2.add(st2);
        list2.add(st3);
        list2.add(st4);
        list2.add(st5);
        StudentInfo2 studentInfo2 = new StudentInfo2();

        /*2*/
        // Использ-ние ЛВ позволяет нам не создавать классы, которые имплементируют этот интерефейс и
        // переписывают метод /test/, т.е. нам не нужно создавать новый класс, имплементировать
        // данный интерфейс, оверайдить метод /test/, потом создавать объект класса и исп-ть
        // объект в параметре метода.    ЛВ позволяют избегать этого длинного кода и решать
        // эту задачу проще.
        // Посмотрим как можно исп-ть ЛВ:

        //   было:   studentInfo2.testStudents(list2, fsog); // fsog - объект класса(этот класс в  Test3 убрали)
        //   System.out.println("-----------------------------------");
        // Стало:

        studentInfo2.testStudents(list2, (Student2 st) -> {return st.avgGrade > 8.5;}); // что это означает? ->
        // второй параметр метода /testStudents/ должен быть типа /StudentChecks1/ интерфейса /StudentChecks1/.
        // До этого в примере как делали: мы создавали класс, который имплементировал /StudentChecks1/ и
        // оверайдили метод /test/, потом мы вставляли сюда (во второй парам-р) объект этого класса.
        // ЛВ позволяют не проделывать этот долгий путь, а сразу написать сюда без создания какого-то
        // класса, как бы уже перезаписанный вариант метода /test/, т.е. как перезаписанный? -> в первых
        // круглых скобках записываем какой параметр принимает этот метод /test/, допустим он принял параметр
        // -/Student2 st/, что он должен сделать? -> и здесь в {} пишем тело этого метода, т.е. после
        // стрелки /->/ пишем что этот метод должен делать в своем теле.
        // Как Java определяет что мы метод /test/ здесь оверайдим? - Java в этом случае позволяет исп-ть ЛВ
        // только тогда, когда вы работаете с интерфейсом, который имеет лишь один метод (ЗАПОМНИТЕ ЭТО)
        // Еще раз повторимся: вместо второго параметра, вместо того чтобы написать объект
        // типа /StudentChecks1 sc/ - это долгий процесс -нужно создавать класс, нужно оверайдить метод,
        // потом создавать объект этого класса в /main/ потом вписывать его сюда | мы вместо этого пишем
        // параметр метода /(Student2 st)/
        // Еще раз объясним как происходит работа этого ЛВ: /(Student2 st) ->{return st.avgGrade >8.5;}/
        // Java понимает, что чтобы испол-ть тип этого интерфейса /StudentChecks1 sc/ нужно оверайдить
        // метод /test/ , здесь же в ЛВ мы делаем оверайд метода /test/ внутри параметра метода /testStudents/
        // Java понимает что здесь в параметре /StudentChecks1 sc/ в методе /testStudents/ если мы используем
        // тип StudentChecks1, то мы можем использовать только его метод /test/, потому что у него другого
        // метода нет и быть не может (а если будет второй метод, то ЛВ работать не будет). Вот такой интерфейс,
        // который в своем теле имеет лишь один метод, называется ФУНКЦИОНАЛЬНЫМ ИНТЕРФЕЙСОМ
        // ЛВ очень похожи на метод оверайдинг - вот (Student2 st) параметр нашего метода, ❗️считайте что здесь
        // написано слово test ♥️ -> потом идет параметр (Student2 s) и потом тело метода. Можно
        // представить так: studentInfo2.testStudents(list2, test(Student2 st) ->{return st.avgGrade >8.5;});
        System.out.println("-----------------------------------");
        // И вывод на экран будет как в предыдущем примере
        // Но насколько сильно мы облегчили написание этого кода?
        // Посмотрим как будем записывать для следующих фильтраций ЛВ
        // В следующих фильтрациях тело метода /boolean test(Student2 s)/ будем
        // писать по другому в этих ЛВ
        studentInfo2.testStudents(list2, (Student2 st) -> {return st.avgGrade < 9;});
        System.out.println("-----------------------------------");
        studentInfo2.testStudents(list2, st -> st.age > 25);  // короткий способ написания
        System.out.println("-----------------------------------");
        studentInfo2.testStudents(list2, st -> {return st.age < 27;}); // смешанный вариант
        System.out.println("-----------------------------------");
        studentInfo2.testStudents(list2, (Student2 st) -> st.sex == 'm'); // смешанный вариант
        System.out.println("-----------------------------------");
        studentInfo2.testStudents(list2, (Student2 st) -> {return st.avgGrade > 7.2 && st.age < 23 && st.sex =='f';});
        System.out.println("-----------------------------------");

        // Дальше мы увидим как еще можно упростить
        // Вы можете думать о ЛВ как об анонимных методах, т.е. у этого метода (Student2 st) есть
        // параметр, у этого метода есть тело {return st.avgGrade < 9;}, но у этого метода нет имени.
        // ЛВ позволяют нам внутрь параметра вставить метод (в качестве параметра используем метод)

        // Самый короткий способ написания ЛВ: (не пишем тип параметра, можем не ставить скобки и в {}
        // stud -> stud.avgGrade > 8.5
        // мы уже можем не брать тело метода, и если в {} не
        // берем то return уже не пишем и /;/ тоже не пишем.
        //     По корот. способу написания: Java сама понимает что /st/ типа Student. Как она понимает?
        // Она видит что мы используем ЛВ - /st -> st.age > 25/. Вместо этого ЛВ что должно было стоять?
        //  -> объект типа /StudentChecks1/. /StudentChecks1/ что это такое? -> Это интерфейс. В интерфейсе
        // один метод? - Да. В параметре этого метода что? - Тип данных Student. Тогда Java
        // говорит -Ok, /st/ я буду считать тоже Student'ом и после стрелочки /->/ покажите мне что
        // возвращает этот метод /test/ - метод /test/ возвращает boolean -вот это сравнение -/st.age > 25/

        // Более полный вариант написания ЛВ:
        // (Student stud) -> {return stud.avgGrade > 8.5;}
        // В ЛВ оператор стрелка разделяет параметры метода и тело метода
        // В ЛВ справа от оператора стрелка находится тело метода, которое было бы у метода
        // соответствующего класса, имплементировавшего наш интерфейс с единственным методом
        // Вы можете использовать смешанный вариант написания ЛВ: слева от оператора стрелка писать
        // короткий вариант, справа - полный. Или наоборот.
        // Если вы исп-ете полный вариант для части ЛВ справа от стрелки, то вы должны исп-ть
        // слово return и знак /;/
        // Если в правой части ЛВ вы пишите более одного statement-а, то вы должны исп-ть
        // полный вариант его написания
        // Смотри примеры в классе Test4

    }


}

interface StudentChecks1 {
    boolean test(Student2 s);
}

